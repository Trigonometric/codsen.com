---
layout: package
title: object-boolean-combinations
---

## Purpose

We need it to test [detergent](/os/detergent/) — it has 11 options and we want to ensure that all 2<sup>12</sup> variations of all possible settings are tested. Currently `detergent` has {{ compiledAssertionCounts.all["detergent"] | thousandSeparator }} asserts, vast majority coming from the asserts on options' variations, generated by this library.

{% include "btt.njk" %}

## API

::: api
{{ packageJsons["object-boolean-combinations"].lect.req }}(inputObject, [overrideObject])
:::

In other words, it's a function which takes two input arguments, second one being optional (marked by square brackets).

{% include "btt.njk" %}

### API - Input

| Input argument   | Type         | Obligatory? | Description                                                                                                                           |
| ---------------- | ------------ | ----------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| `inputObject`    | Plain object | yes         | Plain object from which we should reference the keys.                                                                                 |
| `overrideObject` | Plain object | no          | Keys in this object will be used as-is and will not be used for generating combinations. See [overriding](#overriding) section below. |

{% include "btt.njk" %}

### API - Output

Program returns an array of plain objects.

{% include "btt.njk" %}

## Overriding

Sometimes you want to override the object keys, for example, in the a settings object, we want to override all `a` and `b` keys to be only `true` (`1`). This reduces the object combinations from `2^3 = 8` to: `2^(3-2) = 2^1 = 2`:

```js
const combinations = require("object-boolean-combinations");
const test = combinations(
  { a: 0, b: 0, c: 0 },
  { a: 1, b: 1 } // <----- Override. These values will be on all combinations.
);
console.log(`test = ${JSON.stringify(test, null, 4)}`);
// => [
//      {a: 1, b: 1, c: 0},
//      {a: 1, b: 1, c: 1}
//    ]
```

In example above, `a` and `b` are "pinned" to `1`, thus reducing the amount of combinations by power of two, essentially halving resulting objects count twice. Notice how only `c` is having variations.

{% include "btt.njk" %}

## Overriding the combinations — in practice

In practice, we use this overriding to perform the specific tests on [Detergent.js](/os/detergent/). For example, let's say, we are testing: does Detergent encode entities correctly. In that case we need two arrays filled with objects:

- first array — `encodeEntities = true` and all possible combinations of the other 9 settings (2^(10-1)=512 objects in array)
- second array — `encodeEntities = false` and all possible combinations of the rest — again 512 objects in array.

Here's a unit test which uses `objectBooleanCombinations()` to create a combinations array of settings objects, then uses `forEach()` to iterate through them all, testing each:

```js
test("encode entities - pound sign", (t) => {
  combinations(sampleObj, {
    convertEntities: true,
  }).forEach(function (elem) {
    t.equal(
      detergent("\u00A3", elem),
      "&pound;",
      "pound char converted into entity"
    );
  });
});
```

{% include "btt.njk" %}
