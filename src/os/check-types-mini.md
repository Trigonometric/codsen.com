---
layout: package
title: check-types-mini
---

ℹ️ **2021 update** ℹ️ — we migrated our codebase to TypeScript so options object validation is now automated. We'll aim to maintain this package.

## Purpose

Saves time in Options object validation, at expense of your program's perf:

```js
const checkTypes = require("check-types-mini");

function yourFunction(input, originalOpts) {
  // 1. declare defaults:
  const defaults = { placeholderEnabled: false };
  // 2. merge given opts into defaults:
  const opts = Object.assign({}, defaults, originalOpts);
  // 3. type check:
  checkTypes(opts, defaults, {
    msg: "newLibrary/yourFunction(): [THROW_ID_01]",
  });

  // rest of your app goes here...
}

// NOW, let's call our function with wrong opts and see what happens:
let res = yourFunction(1, { placeholderEnabled: "zzz" }); // <---  notice opts key was Boolean in defaults

// WE GET A TYPE ERROR THROWN:
// =>> TypeError: 'newLibrary/yourFunction(): [THROW_ID_01] opts.placeholderEnabled was customised to "zzz" which is not boolean but string'
```

{% include "btt.njk" %}

## Idea

Imagine you have a library where you let users set the options object, which comes as one of the input arguments.

Here's a challenge: how do you check (and throw) errors easily, when users set your options to wrong things?

Answer: this library. [**2021 edit**: - or TypeScript].

**Features:**

- Use a default options object to enforce types
- Supplement or fully customise types (via a simple schema)
- Customise error messages so that errors show source as your library, even though `check-types-mini` threw them

For example, here's a typical throw error generated by this library:

```js
TypeError: yourLibrary/yourFunction(): [THROW_ID_01] opts.placeholder was customised to "false" which is not boolean but string
```

The point of `check-types-mini` is to save your time: time spent coding up all these checks, time spent debugging, and even consumers' time spent debugging your API when they try to use it wrongly. Every library that has options object will need some **type checks** if you let user tinker with it.

The only drawback is, this program will affect the _performance_ - that's why many apps don't even validate the options' values, especially boolean-ones.

{% include "btt.njk" %}

## API

::: api
checkTypes(obj, [ref, opts])
:::

In other words, it's a function which takes three input arguments, second and third-one optional.

The main and only job of `check-types-mini` is to _throw_ errors when your library's consumers are using it wrongly. Error messages can be customised:

| Input argument | Type         | Obligatory? | Description                                 |
| -------------- | ------------ | ----------- | ------------------------------------------- |
| `obj`          | Plain object | yes         | Options object after user's customisation   |
| `ref`          | Plain object | no^         | Default options - used to compare the types |
| `opts`         | Plain object | no          | Optional options go here.                   |

{% include "btt.njk" %}

### Options object

| `options` object's key | Type                       | Obligatory? | Default                                                                                                          | Description                                                                                                                                                                                                                                                                                                |
| ---------------------- | -------------------------- | ----------- | ---------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ignoreKeys`           | Array or String            | no          | `[]` (empty array)                                                                                               | Instructs to skip all and any checks on keys, specified in this array. Put them as strings.                                                                                                                                                                                                                |
| `ignorePaths`          | Array or String            | no          | `[]` (empty array)                                                                                               | Instructs to skip all and any checks on keys which have given [object-path](https://github.com/mariocasciaro/object-path) notation-style path(s) within the `obj`. A similar thing to `opts.ignoreKeys` above, but unique (because simply key names can appear in multiple places whereas paths are unique). |
| `acceptArrays`         | Boolean                    | no          | `false`                                                                                                          | If it's set to `true`, value can be an array of elements, the same type as reference.                                                                                                                                                                                                                             |
| `acceptArraysIgnore`   | Array of strings or String | no          | `[]` (empty array)                                                                                               | If you want to ignore `acceptArrays` on certain keys, pass them in an array here.                                                                                                                                                                                                                          |
| `enforceStrictKeyset`  | Boolean                    | no          | `true`                                                                                                           | If it's set to `true`, your object must not have any unique keys that reference object (and/or `schema`) does not have.                                                                                                                                                                                    |
| `schema`               | Plain object               | no          | `{}`                                                                                                             | You can set arrays of types for each key, overriding the reference object. This allows you more precision and enforcing multiple types.                                                                                                                                                                    |
| `msg`                  | String                     | no          | `` | A message to show. We like to include the name of the calling library, parent function and numeric throw ID. |
| `optsVarName`          | String                     | no          | `opts`                                                                                                           | How is your options variable called? It does not matter much, but it's nicer to keep references consistent with your API documentation.                                                                                                                                                                    |

Here are all defaults in one place:

```js
{
  ignoreKeys: [],
  ignorePaths: [],
  acceptArrays: false,
  acceptArraysIgnore: [],
  enforceStrictKeyset: true,
  schema: {},
  msg: "check-types-mini",
  optsVarName: "opts"
}
```

{% include "btt.njk" %}

### For example

The common pattern is,

1.  a) Define a defaults object. Later it will be used to validate user's options, PLUS, if that's not enough, you can allow users to provide **arrays** of the matching type (set `opts.acceptArrays` to `true`)
1.  b) Alternatively, you can skip defaults object and provide a schema for each key via `opts.schema`. Just stick an object there, as a value, with all keys. Put allowed types in an array.
1.  `Object.assign` cloned defaults onto the options object that comes from the input.
1.  call `check-types-mini` with the above.
1.  If input types mismatch, an error will be `throw`n.

```js
const checkTypes = require("check-types-mini");

function yourFunction(input, opts) {
  // declare defaults, so we can enforce types later:
  const defaults = {
    placeholder: false,
  };
  // fill any settings with defaults if missing:
  opts = Object.assign({}, defaults, opts);

  // the check:
  checkTypes(opts, defaults, {
    msg: "newLibrary/yourFunction(): [THROW_ID_01]",
    optsVarName: "opts",
  });
  // ...
}

let res = yourFunction(1, { placeholder: "zzz" });

// =>> [TypeError: 'newLibrary/yourFunction(): [THROW_ID_01] opts.placeholder was customised to "zzz" which is not boolean but string']
```

Sometimes you want to accept either value of certain type (like `string`) or array of those (like an array of strings).

For example, if somebody sneaks in an array with strings and one `null`, you want to `throw`.

For these cases set `opts.acceptArrays` to `true`.

This will `throw` an error:

```js
const checkTypes = require("check-types-mini");
checkTypes(
  {
    // < input
    option1: "setting1",
    option2: [true, true],
    option3: false,
  },
  {
    // < reference
    option1: "setting1",
    option2: false,
    option3: false,
  }
);
// => Throws, because reference's `option2` is Boolean ("false") but input `option2` is array ("[true, true]").
```

But when we allow arrays of the matching type, it won't throw anymore:

```js
const checkTypes = require("check-types-mini");
checkTypes(
  {
    option1: "setting1",
    option2: ["setting3", "setting4"],
    option3: false,
  },
  {
    option1: "setting1",
    option2: "setting2",
    option3: false,
  },
  {
    acceptArrays: true,
  }
);
// => Does not throw, because we allow arrays full of a matching type
```

If you want, you can blacklist certain keys of your objects so that `opts.acceptArrays` will not apply to them. Just add keys into `opts.acceptArraysIgnore` array.

{% include "btt.njk" %}

### `opts.enforceStrictKeyset`

When we were coding a new major version of [ast-delete-object](/os/ast-delete-object/), we had to update all the unit tests too. Previously, the settings were set using only one argument, Boolean-type. We had to change it to be a plain object. We noticed that when we missed some tests, their Booleans were `Object.assign`ed into a default settings object and no alarm was being raised! That's not good.

Then we came up with the idea to **enforce the keys of the object** to match the reference and/or schema keys in `options`. It's on by default because we can't imagine how you would end up with settings object that does not match your default settings object, key-wise, but if you don't like that, feel free to turn it off. It's `opts.enforceStrictKeyset` Boolean flag.

{% include "btt.njk" %}

### `opts.schema`

Sometimes your API is more complex than a single type or array of them. Sometimes you want to allow, let's say, `string` or `array` of strings or `null`. What do you do?

Enter `opts.schema`. You can define all the types for particular key, as an array:

```js
const checkTypes = require("check-types-mini");
checkTypes(
  {
    option1: "setting1",
    option2: null,
  },
  {
    option1: "zz",
    option2: "yy", // << notice, it's given as string in defaults object
  },
  {
    schema: {
      option2: ["stRing", null],
    },
  }
);
// => does not throw
```

The types are case-insensitive and come from [type-detect](https://github.com/chaijs/type-detect), a Chai library:

- `'object'` (meaning a plain object literal, nothing else)
- `'array'`
- `'string'`
- `'null'`
- and other usual types

Also, you can use more specific subtypes:

- `'true'`
- `'false'`

The `'true'` and `'false'` are handy in cases when API's accept only one of them, for example, `'false'` and `'string'`, but doesn't accept `'true'`.

For example,

```js
const res = checkTypes(
  {
    // <--- this is object we're checking
    option1: "setting1",
    option2: true, // <--- bad
  },
  {
    // <--- this is default reference object
    option1: "zz",
    option2: null,
  },
  {
    // <--- opts
    schema: {
      option2: ["null", "false", "string"],
    },
  }
);
// => throws an error because `option2` should be either false or string, not true
```

All the type values you put into `opts.schema` _are not validated_, on purpose, so please don't make typos.

{% include "btt.njk" %}

## 2020 update

At first, we aimed to put `check-types-mini` on every npm package that uses options. Then, we became aware of _JS performance_ and started to remove strict input validation, especially in case of booleans and one-level plain objects.

When the program has a complex input object, and you want to validate it, `check-types-mini` is your best friend.

For example, [`ast-monkey`](/os/ast-monkey/) _has_ complex options and needs validation help.

But for one-level-deep options objects, `check-types-mini` is an overkill (unless you don't care about perf).

{% include "btt.njk" %}

## 2021 update

We don't need `check-types-mini` any more!

We rewrote all programs in this monorepo in TypeScript, so now they're shipped with type definitons. This relieves from manual type checks — even if your program which consumes any Codsen packages is not in TypeScript, modern code editors would still pick up the type definitions and show alerts in the UI if you tried to set up wrong input parameters.

{% include "btt.njk" %}