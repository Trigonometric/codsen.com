{"all-named-html-entities":null,"array-group-str-omit-num-char":null,"array-includes-with-glob":null,"array-of-arrays-into-ast":null,"array-of-arrays-sort-by-col":null,"array-pull-all-with-glob":null,"arrayiffy-if-string":null,"ast-compare":null,"ast-contains-only-empty-space":null,"ast-deep-contains":null,"ast-delete-object":null,"ast-get-object":null,"ast-get-values-by-key":null,"ast-is-empty":null,"ast-loose-compare":null,"ast-monkey":null,"ast-monkey-traverse":null,"ast-monkey-traverse-with-lookahead":null,"ast-monkey-util":null,"bitbucket-slug":null,"charcode-is-valid-xml-name-character":null,"check-types-mini":null,"chlu":null,"chlu-cli":null,"codsen-parser":null,"codsen-tokenizer":null,"color-shorthand-hex-to-six-digit":null,"csv-sort":null,"csv-sort-cli":null,"csv-split-easy":null,"detect-is-it-html-or-xhtml":null,"detergent":null,"easy-replace":null,"edit-package-json":null,"email-all-chars-within-ascii":null,"email-all-chars-within-ascii-cli":null,"email-comb":null,"email-homey":null,"emlint":null,"eslint-plugin-row-num":null,"eslint-plugin-test-num":null,"generate-atomic-css":null,"generate-atomic-css-cli":null,"gulp-email-remove-unused-css":null,"helga":null,"html-all-known-attributes":null,"html-crush":null,"html-entities-not-email-friendly":null,"html-img-alt":null,"html-table-patcher":null,"is-char-suitable-for-html-attr-name":null,"is-html-attribute-closing":null,"is-html-tag-opening":null,"is-language-code":null,"is-media-descriptor":null,"is-relative-uri":null,"js-row-num":null,"js-row-num-cli":null,"json-comb":null,"json-comb-core":null,"json-sort-cli":null,"json-variables":null,"lect":null,"lerna-clean-changelogs":null,"lerna-clean-changelogs-cli":null,"lerna-link-dep":null,"object-all-values-equal-to":null,"object-boolean-combinations":null,"object-delete-key":null,"object-fill-missing-keys":null,"object-flatten-all-arrays":null,"object-flatten-referencing":null,"object-merge-advanced":null,"object-no-new-keys":null,"object-set-all-values-to":null,"ranges-apply":null,"ranges-crop":null,"ranges-ent-decode":null,"ranges-invert":null,"ranges-is-index-within":null,"ranges-iterate":null,"ranges-merge":null,"ranges-process-outside":null,"ranges-push":null,"ranges-regex":null,"ranges-sort":null,"regex-empty-conditional-comments":null,"str-indexes-of-plus":null,"string-apostrophes":null,"string-character-is-astral-surrogate":null,"string-collapse-leading-whitespace":null,"string-collapse-white-space":null,"string-convert-indexes":null,"string-extract-class-names":null,"string-extract-sass-vars":null,"string-find-heads-tails":null,"string-find-malformed":null,"string-fix-broken-named-entities":null,"string-left-right":null,"string-match-left-right":null,"string-overlap-one-on-another":null,"string-process-comma-separated":null,"string-range-expander":null,"string-remove-duplicate-heads-tails":null,"string-remove-thousand-separators":null,"string-remove-widows":null,"string-split-by-whitespace":null,"string-strip-html":{"_quickTake.mjs":{"title":"Quick Take","content":"import { strict as assert } from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nassert.equal(\n  stripHtml(`Some text <b>and</b> text.`).result,\n  `Some text and text.`\n);\n\n// prevents accidental string concatenation\nassert.equal(stripHtml(`aaa<div>bbb</div>ccc`).result, `aaa bbb ccc`);\n\n// tag pairs with content, upon request\nassert.equal(\n  stripHtml(`a <pre><code>void a;</code></pre> b`, {\n    stripTogetherWithTheirContents: [\n      \"script\", // default\n      \"style\", // default\n      \"xml\", // default\n      \"pre\", // <-- custom-added\n    ],\n  }).result,\n  `a b`\n);\n\n// detects raw, legit brackets:\nassert.equal(stripHtml(`a < b and c > d`).result, `a < b and c > d`);"},"extract-html-head-contents.mjs":{"title":"Extract HTML head contents","content":"import { strict as assert } from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>\n  <body>\n    the content\n  </body>\n</html>`;\n\n// The task asks not to include <head...> and </head>.\n// First, extract head tag-to-head tag, including contents\nconst headWithHeadTags = stripHtml(someHtml, {\n  onlyStripTags: [\"head\"],\n  stripTogetherWithTheirContents: [\"head\"],\n})\n  .filteredTagLocations.reduce(\n    (acc, [from, to]) => `${acc}${someHtml.slice(from, to)}`,\n    \"\"\n  )\n  .trim();\n\nassert.equal(\n  headWithHeadTags,\n  `<head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>`\n);\n\nconst headContents = headWithHeadTags.replace(/<\\/?head>/g, \"\").trim();\nassert.equal(\n  headContents,\n  `<meta charset=\"utf-8\">\n    <title>the title</title>`\n);"},"leave-only-html.mjs":{"title":"Leave only HTML","content":"import { strict as assert } from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(\n  stripHtml(someHtml).allTagLocations.reduce(\n    (acc, [from, to]) => `${acc}${someHtml.slice(from, to)}`,\n    \"\"\n  ),\n  `<!DOCTYPE html><html lang=\"en\" dir=\"ltr\"><head><meta charset=\"utf-8\"><title></title></head><body><h1></h1></body></html>`\n);"},"leave-only-opening-td.mjs":{"title":"Leave only opening td tags","content":"import { strict as assert } from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\n// the first way\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  stripHtml(someHtml, {\n    // notice there's no: onlyStripTags: [\"td\"]\n    // we operate purely via callback\n    cb: ({ tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn }) => {\n      if (tag.name === \"td\" && !tag.slashPresent) {\n        rangesArr.push(proposedReturn);\n      }\n    },\n  }).ranges.reduce(\n    (acc, [from, to]) => `${acc}${someHtml.slice(from, to).trim()}`,\n    \"\"\n  ),\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);\n\n// the second way:\n// -----------------------------------------------------------------------------\n\nlet resultStr = \"\";\n// notice we don't even assign stripHtml() output to anything - we rely only\n// on the callback, it mutates the \"resultStr\" in the upper scope\nstripHtml(someHtml, {\n  // notice there's no: onlyStripTags: [\"td\"]\n  // we operate purely via callback\n  cb: ({ tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn }) => {\n    if (tag.name === \"td\" && !tag.slashPresent) {\n      resultStr += someHtml.slice(deleteFrom, deleteTo).trim();\n    }\n  },\n});\nassert.equal(\n  resultStr,\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);"},"leave-only-td.mjs":{"title":"Leave only td tags","content":"import { strict as assert } from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\nassert.equal(\n  stripHtml(someHtml, {\n    onlyStripTags: [\"td\"],\n  }).filteredTagLocations.reduce(\n    (acc, [from, to]) => `${acc}${someHtml.slice(from, to)}`,\n    \"\"\n  ),\n  `<td class=\"col1\"></td><td class=\"col2\"></td><td class=\"col3\"></td><td class=\"col4\"></td>`\n);"},"remove-html.mjs":{"title":"Remove all HTML from a string","content":"import { strict as assert } from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(stripHtml(someHtml).result, `Title\\nSome text.`);"}},"string-trim-spaces-only":null,"string-uglify":null,"string-unfancy":null,"tap-parse-string-to-object":null,"update-versions":null,"util-array-object-or-both":null,"util-nonempty":null}